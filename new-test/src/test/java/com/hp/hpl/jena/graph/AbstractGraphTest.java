/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hp.hpl.jena.graph;

import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import org.junit.Test;
import static org.junit.Assert.*;

import com.hp.hpl.jena.graph.Capabilities;
import com.hp.hpl.jena.graph.Graph;
import com.hp.hpl.jena.graph.GraphStatisticsHandler;
import com.hp.hpl.jena.graph.GraphUtil;
import com.hp.hpl.jena.graph.Node;
import com.hp.hpl.jena.graph.Triple;
import com.hp.hpl.jena.graph.impl.LiteralLabelFactory;
import com.hp.hpl.jena.mem.TrackingTripleIterator;
import com.hp.hpl.jena.rdf.model.Model;
import com.hp.hpl.jena.rdf.model.ModelFactory;
import com.hp.hpl.jena.rdf.model.impl.ReifierStd;
import com.hp.hpl.jena.shared.ClosedException;
import com.hp.hpl.jena.testing_framework.AbstractGraphProducerUser;
import com.hp.hpl.jena.util.CollectionFactory;
import com.hp.hpl.jena.util.iterator.ClosableIterator;
import com.hp.hpl.jena.util.iterator.ExtendedIterator;

import static com.hp.hpl.jena.testing_framework.GraphTestUtils.*;

/**
 * AbstractTestGraph provides a bunch of basic tests for something that purports
 * to be a Graph. The abstract method getGraph must be overridden in subclasses
 * to deliver a Graph of interest.
 */

public abstract class AbstractGraphTest extends AbstractGraphProducerUser {

	protected Graph graphWithTxn(String s) {
		Graph g = getGraphProducer().newGraph();
		txnBegin(g);
		try {
			graphAdd(g, s);
			txnCommit(g);
		} catch (Exception e) {
			txnRollback(g);
			fail(e.getMessage());
		}
		return g;
	}

	@Test
	public void testCloseSetsIsClosed() {
		Graph g = getGraphProducer().newGraph();
		assertFalse("unclosed Graph shouild not be isClosed()", g.isClosed());
		g.close();
		assertTrue("closed Graph should be isClosed()", g.isClosed());
	}

	/**
	 * This test case was generated by Ian and was caused by GraphMem not
	 * keeping up with changes to the find interface.
	 */
	@Test
	public void testFindAndContains() {
		Graph g = getGraphProducer().newGraph();
		Node r = NodeCreateUtils.create("r"), s = NodeCreateUtils.create("s"), p = NodeCreateUtils
				.create("P");
		txnBegin(g);
		try {
			g.add(Triple.create(r, p, s));
			txnCommit(g);
			assertTrue(g.contains(r, p, Node.ANY));
			assertEquals(1, g.find(r, p, Node.ANY).toList().size());
		} catch (Exception e) {
			txnRollback(g);
			fail(e.getMessage());
		}
	}

	@Test
	public void testRepeatedSubjectDoesNotConceal() {

		Graph g = graphWithTxn("s P o; s Q r");
		assertTrue(g.contains(triple("s P o")));
		assertTrue(g.contains(triple("s Q r")));
		assertTrue(g.contains(triple("?? P o")));
		assertTrue(g.contains(triple("?? Q r")));
		assertTrue(g.contains(triple("?? P ??")));
		assertTrue(g.contains(triple("?? Q ??")));
	}

	@Test
	public void testFindByFluidTriple() {
		Graph g = graphWithTxn("x y z ");
		Set<Triple> expect = tripleSet("x y z");
		assertEquals(expect, g.find(triple("?? y z")).toSet());
		assertEquals(expect, g.find(triple("x ?? z")).toSet());
		assertEquals(expect, g.find(triple("x y ??")).toSet());
	}

	@Test
	public void testContainsConcrete() {
		Graph g = graphWithTxn("s P o; _x _R _y; x S 0");
		assertTrue(g.contains(triple("s P o")));
		assertTrue(g.contains(triple("_x _R _y")));
		assertTrue(g.contains(triple("x S 0")));
		/* */
		assertFalse(g.contains(triple("s P Oh")));
		assertFalse(g.contains(triple("S P O")));
		assertFalse(g.contains(triple("s p o")));
		assertFalse(g.contains(triple("_x _r _y")));
		assertFalse(g.contains(triple("x S 1")));
	}

	@Test
	public void testContainsFluid() {
		Graph g = graphWithTxn("x R y; a P b");
		assertTrue(g.contains(triple("?? R y")));
		assertTrue(g.contains(triple("x ?? y")));
		assertTrue(g.contains(triple("x R ??")));
		assertTrue(g.contains(triple("?? P b")));
		assertTrue(g.contains(triple("a ?? b")));
		assertTrue(g.contains(triple("a P ??")));
		assertTrue(g.contains(triple("?? R y")));
		/* */
		assertFalse(g.contains(triple("?? R b")));
		assertFalse(g.contains(triple("a ?? y")));
		assertFalse(g.contains(triple("x P ??")));
		assertFalse(g.contains(triple("?? R x")));
		assertFalse(g.contains(triple("x ?? R")));
		assertFalse(g.contains(triple("a S ??")));
	}

	/**
	 * Check that contains respects by-value semantics.
	 */
	@Test
	public void testContainsByValue() {
		if (getGraphProducer().newGraph().getCapabilities()
				.handlesLiteralTyping()) {
			Graph g1 = graphWithTxn("x P '1'xsd:integer");
			assertTrue(g1.contains(triple("x P '01'xsd:int")));
			//
			Graph g2 = graphWithTxn("x P '1'xsd:int");
			assertTrue(g2.contains(triple("x P '1'xsd:integer")));
			//
			Graph g3 = graphWithTxn("x P '123'xsd:string");
			assertTrue(g3.contains(triple("x P '123'")));
		}
	}

	@Test
	public void testProgrammaticValues() {
		Graph g = getGraphProducer().newGraph();
		if (g.getCapabilities().handlesLiteralTyping()) {
			Node ab = NodeFactory.createLiteral(LiteralLabelFactory
					.create(new Byte((byte) 42)));
			Node as = NodeFactory.createLiteral(LiteralLabelFactory
					.create(new Short((short) 42)));
			Node ai = NodeFactory.createLiteral(LiteralLabelFactory
					.create(new Integer(42)));
			Node al = NodeFactory.createLiteral(LiteralLabelFactory
					.create(new Long(42)));

			Node SB = NodeCreateUtils.create("SB");
			Node SS = NodeCreateUtils.create("SS");
			Node SI = NodeCreateUtils.create("SI");
			Node SL = NodeCreateUtils.create("SL");
			Node P = NodeCreateUtils.create("P");

			txnBegin(g);
			try {
				g.add(Triple.create(SB, P, ab));
				g.add(Triple.create(SS, P, as));
				g.add(Triple.create(SI, P, ai));
				g.add(Triple.create(SL, P, al));
			} catch (Exception e) {
				txnRollback(g);
				fail(e.getMessage());
			}
			txnCommit(g);
			assertEquals(
					4,
					iteratorToSet(
							g.find(Node.ANY, P, NodeCreateUtils.create("42")))
							.size());
		}
	}

	@Test
	public void testMatchLanguagedLiteralCaseInsensitive() {
		Graph m = graphWithTxn("a p 'chat'en");
		if (m.getCapabilities().handlesLiteralTyping()) {
			Node chaten = node("'chat'en"), chatEN = node("'chat'EN");
			assertDiffer(chaten, chatEN);
			assertTrue(chaten.sameValueAs(chatEN));
			assertEquals(chaten.getIndexingValue(), chatEN.getIndexingValue());
			assertEquals(1, m.find(Node.ANY, Node.ANY, chaten).toList().size());
			assertEquals(1, m.find(Node.ANY, Node.ANY, chatEN).toList().size());
		}
	}

	@Test
	public void testMatchBothLanguagedLiteralsCaseInsensitive() {
		Graph m = graphWithTxn("a p 'chat'en; a p 'chat'EN");
		if (m.getCapabilities().handlesLiteralTyping()) {
			Node chaten = node("'chat'en"), chatEN = node("'chat'EN");
			assertDiffer(chaten, chatEN);
			assertTrue(chaten.sameValueAs(chatEN));
			assertEquals(chaten.getIndexingValue(), chatEN.getIndexingValue());
			assertEquals(2, m.find(Node.ANY, Node.ANY, chaten).toList().size());
			assertEquals(2, m.find(Node.ANY, Node.ANY, chatEN).toList().size());
		}
	}

	@Test
	public void testNoMatchAgainstUnlanguagesLiteral() {
		Graph m = graphWithTxn("a p 'chat'en; a p 'chat'");
		if (m.getCapabilities().handlesLiteralTyping()) {
			Node chaten = node("'chat'en"), chatEN = node("'chat'EN");
			assertDiffer(chaten, chatEN);
			assertTrue(chaten.sameValueAs(chatEN));
			assertEquals(chaten.getIndexingValue(), chatEN.getIndexingValue());
			assertEquals(1, m.find(Node.ANY, Node.ANY, chaten).toList().size());
			assertEquals(1, m.find(Node.ANY, Node.ANY, chatEN).toList().size());
		}
	}

	/**
	 * test isEmpty - moved from the QueryHandler code.
	 */
	@Test
	public void testIsEmpty() {
		Graph g = getGraphProducer().newGraph();
		if (canBeEmpty(g)) {
			assertTrue(g.isEmpty());
			txnBegin(g);
			g.add(NodeCreateUtils.createTriple("S P O"));
			txnCommit(g);
			assertFalse(g.isEmpty());
			txnBegin(g);
			g.add(NodeCreateUtils.createTriple("A B C"));
			txnCommit(g);
			assertFalse(g.isEmpty());
			txnBegin(g);
			g.add(NodeCreateUtils.createTriple("S P O"));
			txnCommit(g);
			assertFalse(g.isEmpty());
			txnBegin(g);
			g.delete(NodeCreateUtils.createTriple("S P O"));
			txnCommit(g);
			assertFalse(g.isEmpty());
			txnBegin(g);
			g.delete(NodeCreateUtils.createTriple("A B C"));
			txnCommit(g);
			assertTrue(g.isEmpty());
		}
	}

	@Test
	public void testAGraph() {
		String title = this.getClass().getName();
		Graph g = getGraphProducer().newGraph();
		int baseSize = g.size();
		graphAddTxn(g, "x R y; p S q; a T b");
		/* */
		assertContainsAll(title + ": simple graph", g, "x R y; p S q; a T b");
		assertEquals(title + ": size", baseSize + 3, g.size());

		graphAddTxn(g,
				"spindizzies lift cities; Diracs communicate instantaneously");
		assertEquals(title + ": size after adding", baseSize + 5, g.size());
		txnBegin(g);
		g.delete(triple("x R y"));
		g.delete(triple("a T b"));
		txnCommit(g);
		assertEquals(title + ": size after deleting", baseSize + 3, g.size());
		assertContainsAll(title + ": modified simple graph", g,
				"p S q; spindizzies lift cities; Diracs communicate instantaneously");
		assertOmitsAll(title + ": modified simple graph", g, "x R y; a T b");
		/* */
		ClosableIterator<Triple> it = g.find(Node.ANY, node("lift"), Node.ANY);
		assertTrue(title + ": finds some triple(s)", it.hasNext());
		assertEquals(title + ": finds a 'lift' triple",
				triple("spindizzies lift cities"), it.next());
		assertFalse(title + ": finds exactly one triple", it.hasNext());
		it.close();
	}

	// public void testStuff()
	// {
	// // testAGraph( "StoreMem", new GraphMem() );
	// // testAGraph( "StoreMemBySubject", new GraphMem() );
	// // String [] empty = new String [] {};
	// // Graph g = graphWith( "x R y; p S q; a T b" );
	// // /* */
	// // assertContainsAll( "simple graph", g, "x R y; p S q; a T b" );
	// // graphAdd( g,
	// "spindizzies lift cities; Diracs communicate instantaneously" );
	// // g.delete( triple( "x R y" ) );
	// // g.delete( triple( "a T b" ) );
	// // assertContainsAll( "modified simple graph", g,
	// "p S q; spindizzies lift cities; Diracs communicate instantaneously" );
	// // assertOmitsAll( "modified simple graph", g, "x R y; a T b" );
	// }

	// /**
	// Test that Graphs have transaction support methods, and that if they fail
	// on some g they fail because they do not support the operation.
	// */
	// @Test
	// public void testHasTransactions()
	// {
	// Graph g = getGraphProducer().newGraph();
	// TransactionHandler th = g.getTransactionHandler();
	// th.transactionsSupported();
	// try { th.begin(); } catch (UnsupportedOperationException x) {}
	// try { th.abort(); } catch (UnsupportedOperationException x) {}
	// try { th.begin(); th.commit(); } catch (UnsupportedOperationException x)
	// {}
	// /* */
	// Command cmd = new Command()
	// { @Override
	// public Object execute() { return null; } };
	// try { th.executeInTransaction( cmd ); }
	// catch (UnsupportedOperationException x) {}
	// }
	//
	// @Test
	// public void testExecuteInTransactionCatchesThrowable()
	// {Graph g = getGraphProducer().newGraph();
	// TransactionHandler th = g.getTransactionHandler();
	// if (th.transactionsSupported())
	// {
	// Command cmd = new Command()
	// { @Override
	// public Object execute() throws Error { throw new Error(); } };
	// try { th.executeInTransaction( cmd ); }
	// catch (JenaException x) {}
	// }
	// }

	protected static final Triple[] tripleArray = tripleArray("S P O; A R B; X Q Y");

	protected static final List<Triple> tripleList = Arrays
			.asList(tripleArray("i lt j; p equals q"));

	protected static final Triple[] setTriples = tripleArray("scissors cut paper; paper wraps stone; stone breaks scissors");

	protected static final Set<Triple> tripleSet = CollectionFactory
			.createHashedSet(Arrays.asList(setTriples));

	@Test
	public void testBulkUpdate() {
		Graph g = getGraphProducer().newGraph();
		Graph items = graphWithTxn("pigs might fly; dead can dance");
		int initialSize = g.size();
		/* */
		txnBegin(g);
		GraphUtil.add(g, tripleArray);
		txnCommit(g);
		testContains(g, tripleArray);
		testOmits(g, tripleList);
		/* */
		txnBegin(g);
		GraphUtil.add(g, tripleList);
		txnCommit(g);
		testContains(g, tripleList);
		testContains(g, tripleArray);
		/* */
		txnBegin(g);
		GraphUtil.add(g, tripleSet.iterator());
		txnCommit(g);
		testContains(g, tripleSet.iterator());
		testContains(g, tripleList);
		testContains(g, tripleArray);
		/* */
		txnBegin(g);
		GraphUtil.addInto(g, items);
		txnCommit(g);
		testContains(g, items);
		testContains(g, tripleSet.iterator());
		testContains(g, tripleArray);
		testContains(g, tripleList);
		/* */
		txnBegin(g);
		GraphUtil.delete(g, tripleArray);
		txnCommit(g);
		testOmits(g, tripleArray);
		testContains(g, tripleList);
		testContains(g, tripleSet.iterator());
		testContains(g, items);
		/* */
		txnBegin(g);
		GraphUtil.delete(g, tripleSet.iterator());
		txnCommit(g);
		testOmits(g, tripleSet.iterator());
		testOmits(g, tripleArray);
		testContains(g, tripleList);
		testContains(g, items);
		/* */
		txnBegin(g);
		GraphUtil.deleteFrom(g, items);
		txnCommit(g);
		testOmits(g, tripleSet.iterator());
		testOmits(g, tripleArray);
		testContains(g, tripleList);
		testOmits(g, items);
		/* */
		txnBegin(g);
		GraphUtil.delete(g, tripleList);
		txnCommit(g);
		assertEquals("graph has original size", initialSize, g.size());
	}

	@Test
	public void testAddWithReificationPreamble() {
		Graph g = getGraphProducer().newGraph();
		txnBegin(g);
		xSPO(g);
		txnCommit(g);
		assertFalse(g.isEmpty());
	}

	protected void xSPOyXYZ(Graph g) {
		xSPO(g);
		ReifierStd.reifyAs(g, NodeCreateUtils.create("y"),
				NodeCreateUtils.createTriple("X Y Z"));
	}

	protected void aABC(Graph g) {
		ReifierStd.reifyAs(g, NodeCreateUtils.create("a"),
				NodeCreateUtils.createTriple("A B C"));
	}

	protected void xSPO(Graph g) {
		ReifierStd.reifyAs(g, NodeCreateUtils.create("x"),
				NodeCreateUtils.createTriple("S P O"));
	}

	@Test
	public void testRemove() {
		testRemove("?? ?? ??", "?? ?? ??");
		testRemove("S ?? ??", "S ?? ??");
		testRemove("S ?? ??", "?? P ??");
		testRemove("S ?? ??", "?? ?? O");
		testRemove("?? P ??", "S ?? ??");
		testRemove("?? P ??", "?? P ??");
		testRemove("?? P ??", "?? ?? O");
		testRemove("?? ?? O", "S ?? ??");
		testRemove("?? ?? O", "?? P ??");
		testRemove("?? ?? O", "?? ?? O");
	}

	protected void testRemove(String findRemove, String findCheck) {
		Graph g = graphWithTxn("S P O");
		ExtendedIterator<Triple> it = g.find(NodeCreateUtils
				.createTriple(findRemove));
		try {
			it.next();
			it.remove();
			it.close();
			assertEquals("remove with " + findRemove + ":", 0, g.size());
			assertFalse(g.contains(NodeCreateUtils.createTriple(findCheck)));
		} catch (UnsupportedOperationException e) {
			it.close();
			assertFalse(g.getCapabilities().iteratorRemoveAllowed());
		}
		it.close();
	}

	@Test
	public void testFind() {
		Graph g = graphWithTxn("S P O");
		assertDiffer(new HashSet<Triple>(), g
				.find(Node.ANY, Node.ANY, Node.ANY).toSet());
		assertDiffer(new HashSet<Triple>(), g.find(Triple.ANY).toSet());
	}

	protected boolean canBeEmpty(Graph g) {
		return g.isEmpty();
	}

	@Test
	public void testListSubjects() {
		Set<Node> emptySubjects = listSubjects(graphWithTxn(""));
		Graph g = graphWithTxn("x P y; y Q z");
		assertEquals(nodeSet("x y"), remove(listSubjects(g), emptySubjects));
		txnBegin(g);
		g.delete(triple("x P y"));
		txnCommit(g);
		assertEquals(nodeSet("y"), remove(listSubjects(g), emptySubjects));
	}

	protected Set<Node> listSubjects(Graph g) {
		return GraphUtil.listSubjects(g, Node.ANY, Node.ANY).toSet();
	}

	@Test
	public void testListPredicates() {
		Set<Node> emptyPredicates = listPredicates(graphWithTxn(""));
		Graph g = graphWithTxn("x P y; y Q z");
		assertEquals(nodeSet("P Q"), remove(listPredicates(g), emptyPredicates));
		txnBegin(g);
		g.delete(triple("x P y"));
		txnCommit(g);
		assertEquals(nodeSet("Q"), remove(listPredicates(g), emptyPredicates));
	}

	protected Set<Node> listPredicates(Graph g) {
		return GraphUtil.listPredicates(g, Node.ANY, Node.ANY).toSet();
	}

	@Test
	public void testListObjects() {
		Set<Node> emptyObjects = listObjects(graphWithTxn(""));
		Graph g = graphWithTxn("x P y; y Q z");
		assertEquals(nodeSet("y z"), remove(listObjects(g), emptyObjects));
		txnBegin(g);
		g.delete(triple("x P y"));
		txnCommit(g);
		assertEquals(nodeSet("z"), remove(listObjects(g), emptyObjects));
	}

	protected Set<Node> listObjects(Graph g) {
		return GraphUtil.listObjects(g, Node.ANY, Node.ANY).toSet();
	}

	/**
	 * Answer a set with all the elements of <code>A</code> except those in
	 * <code>B</code>.
	 */
	private <T> Set<T> remove(Set<T> A, Set<T> B) {
		Set<T> result = new HashSet<T>(A);
		result.removeAll(B);
		return result;
	}

	/**
	 * Test that nodes can be found in all triple positions. However, testing
	 * for literals in subject positions is suppressed at present to avoid
	 * problems with InfGraphs which try to prevent such constructs leaking out
	 * to the RDF layer.
	 */
	@Test
	public void testContainsNode() {
		Graph g = graphWithTxn("a P b; _c p1 _D; a P2 12");
		assertTrue(containsNode(g, node("a")));
		assertTrue(containsNode(g, node("P")));
		assertTrue(containsNode(g, node("b")));
		assertTrue(containsNode(g, node("_c")));
		assertTrue(containsNode(g, node("p1")));
		assertTrue(containsNode(g, node("_D")));
		// assertTrue( qh.containsNode( node( "10" ) ) );
		// assertTrue(containsNode(g, node("11")));
		assertTrue(containsNode(g, node("12")));
		/* */
		assertFalse(containsNode(g, node("x")));
		assertFalse(containsNode(g, node("_y")));
		assertFalse(containsNode(g, node("99")));
	}

	private boolean containsNode(Graph g, Node node) {
		return GraphUtil.containsNode(g, node);
	}

	@Test
	public void testSubjectsFor() {
		// First get the answer from the empty graph (not empty for an inf
		// graph)
		Graph b = graphWithTxn("");
		Set<Node> B = GraphUtil.listSubjects(b, Node.ANY, Node.ANY).toSet();

		Graph g = graphWithTxn("a P b; a Q c; a P d; b P x; c Q y");

		testSubjects(g, B, Node.ANY, Node.ANY, node("a"), node("b"), node("c"));
		testSubjects(g, B, node("P"), Node.ANY, node("a"), node("b"));
		testSubjects(g, B, node("Q"), node("c"), node("a"));
		testSubjects(g, B, node("Q"), node("y"), node("c"));
		testSubjects(g, B, node("Q"), node("a"));
		testSubjects(g, B, node("Q"), node("z"));
	}

	protected void testSubjects(Graph g, Collection<Node> exclude, Node p,
			Node o, Node... expected) {
		List<Node> R = GraphUtil.listSubjects(g, p, o).toList();
		R.removeAll(exclude);
		assertSameUnordered(R, exclude, expected);
	}

	// Same - except for order
	private void assertSameUnordered(List<Node> x1, Collection<Node> exclude,
			Node[] expected) {
		List<Node> x = new ArrayList<Node>();
		x.addAll(x1);
		x.removeAll(exclude);

		assertEquals(expected.length, x.size());
		Set<Node> X = new HashSet<Node>();
		X.addAll(x);

		Set<Node> R = new HashSet<Node>();
		R.addAll(Arrays.asList(expected));

		assertEquals(R, X);

	}

	@Test
	public void testListSubjectsNoRemove() {
		Graph g = graphWithTxn("a P b; b Q c; c R a");
		Iterator<Node> it = GraphUtil.listSubjects(g, Node.ANY, Node.ANY);
		it.next();
		try {
			it.remove();
			fail("listSubjects for " + g.getClass()
					+ " should not support .remove()");
		} catch (UnsupportedOperationException expected) {
			// expected result
		}
	}

	@Test
	public void testObjectsFor() {
		// First get the answer from the empty graph (not empty for an inf
		// graph)
		Graph b = graphWithTxn("");
		Set<Node> B = GraphUtil.listObjects(b, Node.ANY, Node.ANY).toSet();

		Graph g = graphWithTxn("b P a; c Q a; d P a; x P b; y Q c");
		testObjects(g, B, Node.ANY, Node.ANY, node("a"), node("b"), node("c"));
		testObjects(g, B, Node.ANY, node("P"), node("a"), node("b"));
		testObjects(g, B, node("c"), node("Q"), node("a"));
		testObjects(g, B, node("y"), node("Q"), node("c"));
		testObjects(g, B, node("a"), node("Q"));
		testObjects(g, B, node("z"), node("Q"));
	}

	protected void testObjects(Graph g, Collection<Node> exclude, Node s,
			Node p, Node... expected) {
		List<Node> X = GraphUtil.listObjects(g, s, p).toList();
		assertSameUnordered(X, exclude, expected);
	}

	@Test
	public void testPredicatesFor() {
		// First get the answer from the empty graph (not empty for an inf
		// graph)
		Graph b = graphWithTxn("");
		Set<Node> B = GraphUtil.listPredicates(b, Node.ANY, Node.ANY).toSet();

		Graph g = graphWithTxn("a P b; z P b; c Q d; e R f; g P b; h Q i");
		testPredicates(g, B, Node.ANY, Node.ANY, node("P"), node("Q"),
				node("R"));
		testPredicates(g, B, Node.ANY, node("b"), node("P"));
		testPredicates(g, B, node("g"), Node.ANY, node("P"));
		testPredicates(g, B, node("c"), node("d"), node("Q"));
		testPredicates(g, B, node("e"), node("f"), node("R"));
		testPredicates(g, B, node("e"), node("a"));
		testPredicates(g, B, node("z"), node("y"));
	}

	protected void testPredicates(Graph g, Collection<Node> exclude, Node s,
			Node o, Node... expected) {
		List<Node> X = GraphUtil.listPredicates(g, s, o).toList();
		assertSameUnordered(X, exclude, expected);
	}

	@Test
	public void testListObjectsNoRemove() {
		Graph g = graphWithTxn("a P b; b Q c; c R a");
		Iterator<Node> it = GraphUtil.listObjects(g, Node.ANY, Node.ANY);
		it.next();
		try {
			it.remove();
			fail("listObjects for " + g.getClass()
					+ " should not support .remove()");
		} catch (UnsupportedOperationException e) {
			// expected
		}
	}

	@Test
	public void testListPredicatesNoRemove() {
		Graph g = graphWithTxn("a P b; b Q c; c R a");
		Iterator<Node> it = GraphUtil.listPredicates(g, Node.ANY, Node.ANY);
		it.next();
		try {
			it.remove();
			fail("listPredicates for " + g.getClass()
					+ " should not support .remove()");
		} catch (UnsupportedOperationException e) {
			// expected
		}
	}

	@Test
	public void testRemoveAll() {
		testRemoveAll("");
		testRemoveAll("a R b");
		testRemoveAll("c S d; e:ff GGG hhhh; _i J 27; Ell Em 'en'");
	}

	protected void testRemoveAll(String triples) {
		Graph g = graphWithTxn(triples);
		txnBegin(g);
		g.clear();
		txnCommit(g);
		assertTrue(g.isEmpty());
	}

	@Test
	public void failingTestDoubleRemoveAll() {
		final Graph g = getGraphProducer().newGraph();
		if (g.getCapabilities().iteratorRemoveAllowed()) {
			graphAddTxn(g, "c S d; e:ff GGG hhhh; _i J 27; Ell Em 'en'");
			Iterator<Triple> it = new TrackingTripleIterator(g.find(Triple.ANY)) {
				@Override
				public void remove() {
					super.remove(); // removes current
					g.delete(current); // no-op.
				}
			};
			while (it.hasNext()) {
				it.next();
				it.remove();
			}
			assertTrue(g.isEmpty());
		}
	}

	@Test
	public void testGetStatisticsHandler() {
		Graph g = getGraphProducer().newGraph();
		GraphStatisticsHandler h = g.getStatisticsHandler();
		assertSame(h, g.getStatisticsHandler());
	}

	/**
	 * Test cases for RemoveSPO(); each entry is a triple (add, remove, result).
	 * <ul>
	 * <li>add - the triples to add to the graph to start with
	 * <li>remove - the pattern to use in the removal
	 * <li>result - the triples that should remain in the graph
	 * </ul>
	 */
	protected static String[][] cases = { { "x R y", "x R y", "" },
			{ "x R y; a P b", "x R y", "a P b" },
			{ "x R y; a P b", "?? R y", "a P b" },
			{ "x R y; a P b", "x R ??", "a P b" },
			{ "x R y; a P b", "x ?? y", "a P b" },
			{ "x R y; a P b", "?? ?? ??", "" },
			{ "x R y; a P b; c P d", "?? P ??", "x R y" },
			{ "x R y; a P b; x S y", "x ?? ??", "a P b" }, };

	/**
	 * Test that remove(s, p, o) works, in the presence of inferencing graphs
	 * that mean emptyness isn't available. This is why we go round the houses
	 * and test that expected ~= initialContent + addedStuff - removed -
	 * initialContent.
	 */
	@Test
	public void testRemoveSPO() {
		for (int i = 0; i < cases.length; i += 1)
			for (int j = 0; j < 3; j += 1) {
				Graph content = getGraphProducer().newGraph();
				Graph baseContent = copy(content);
				graphAddTxn(content, cases[i][0]);
				Triple remove = triple(cases[i][1]);
				Graph expected = graphWithTxn(cases[i][2]);
				txnBegin(content);
				content.remove(remove.getSubject(), remove.getPredicate(),
						remove.getObject());
				txnCommit(content);
				Graph finalContent = remove(copy(content), baseContent);
				assertIsomorphic(cases[i][1], expected, finalContent);
			}
	}

	/**
	 * testIsomorphism from file data
	 * 
	 * @throws FileNotFoundException
	 */
	@Test
	public void testIsomorphismFile() throws URISyntaxException,
			MalformedURLException {
		testIsomorphismXMLFile(1, true);
		testIsomorphismXMLFile(2, true);
		testIsomorphismXMLFile(3, true);
		testIsomorphismXMLFile(4, true);
		testIsomorphismXMLFile(5, false);
		testIsomorphismXMLFile(6, false);
		testIsomorphismNTripleFile(7, true);
		testIsomorphismNTripleFile(8, false);

	}

	private void testIsomorphismNTripleFile(int i, boolean result)
			throws URISyntaxException, MalformedURLException {
		testIsomorphismFile(i, "N-TRIPLE", "nt", result);
	}

	private void testIsomorphismXMLFile(int i, boolean result)
			throws URISyntaxException, MalformedURLException {
		testIsomorphismFile(i, "RDF/XML", "rdf", result);

	}

	private InputStream getInputStream(int n, int n2, String suffix)
			throws URISyntaxException, MalformedURLException {
		String urlStr = String.format("regression/testModelEquals/%s-%s.%s", n,
				n2, suffix);
		return AbstractGraphTest.class.getClassLoader().getResourceAsStream(
				urlStr);
	}

	private void testIsomorphismFile(int n, String lang, String suffix,
			boolean result) throws URISyntaxException, MalformedURLException {

		Graph g1 = getGraphProducer().newGraph();
		Graph g2 = getGraphProducer().newGraph();
		Model m1 = ModelFactory.createModelForGraph(g1);
		Model m2 = ModelFactory.createModelForGraph(g2);

		m1.read(getInputStream(n, 1, suffix), "http://www.example.org/", lang);

		m2.read(getInputStream(n, 2, suffix), "http://www.example.org/", lang);

		boolean rslt = g1.isIsomorphicWith(g2) == result;
		if (!rslt) {
			System.out.println("g1:");
			m1.write(System.out, "N-TRIPLE");
			System.out.println("g2:");
			m2.write(System.out, "N-TRIPLE");
		}
		assertTrue("Isomorphism test failed", rslt);
	}

	protected void add(Graph toUpdate, Graph toAdd) {
		txnBegin(toUpdate);
		GraphUtil.addInto(toUpdate, toAdd);
		txnCommit(toUpdate);
	}

	protected Graph remove(Graph toUpdate, Graph toRemove) {
		txnBegin(toUpdate);
		GraphUtil.deleteFrom(toUpdate, toRemove);
		txnCommit(toUpdate);
		return toUpdate;
	}

	protected Graph copy(Graph g) {
		Graph result = getGraphProducer().newGraph();
		txnBegin(result);
		GraphUtil.addInto(result, g);
		txnCommit(result);
		return result;
	}

	protected Graph getClosed() {
		Graph result = getGraphProducer().newGraph();
		result.close();
		return result;
	}

	public void testClosedDelete() {
		try {
			getClosed().delete(triple("x R y"));
			fail("delete when closed");
		} catch (ClosedException c) { /* as required */
		}
	}

	public void testClosedAdd() {
		try {
			getClosed().add(triple("x R y"));
			fail("add when closed");
		} catch (ClosedException c) { /* as required */
		}
	}

	public void testClosedContainsTriple() {
		try {
			getClosed().contains(triple("x R y"));
			fail("contains[triple] when closed");
		} catch (ClosedException c) { /* as required */
		}
	}

	public void testClosedContainsSPO() {
		Node a = Node.ANY;
		try {
			getClosed().contains(a, a, a);
			fail("contains[SPO] when closed");
		} catch (ClosedException c) { /* as required */
		}
	}

	public void testClosedFindTriple() {
		try {
			getClosed().find(triple("x R y"));
			fail("find [triple] when closed");
		} catch (ClosedException c) { /* as required */
		}
	}

	public void testClosedFindSPO() {
		Node a = Node.ANY;
		try {
			getClosed().find(a, a, a);
			fail("find[SPO] when closed");
		} catch (ClosedException c) { /* as required */
		}
	}

	public void testClosedSize() {
		try {
			getClosed().size();
			fail("size when closed (" + this.getClass() + ")");
		} catch (ClosedException c) { /* as required */
		}
	}

	@Test
	public void testCapabilitiesAvailable() {
		Graph g = getGraphProducer().newGraph();
		Capabilities c = g.getCapabilities();
		assertNotNull("Capabilities are not returned", c);
		try {
			c.sizeAccurate();
		} catch (Exception e) {
			fail("sizeAccurate() threw Exception: " + e.toString());
		}
		try {
			c.addAllowed();
		} catch (Exception e) {
			fail("addAllowed() threw Exception: " + e.toString());
		}
		try {
			c.addAllowed(true);
		} catch (Exception e) {
			fail("addAllowed( boolean ) threw Exception: " + e.toString());
		}
		try {
			c.deleteAllowed();
		} catch (Exception e) {
			fail("deleteAllowed() threw Exception: " + e.toString());
		}
		try {
			c.deleteAllowed(true);
		} catch (Exception e) {
			fail("deleteAllowed( boolean ) threw Exception: " + e.toString());
		}
		try {
			c.canBeEmpty();
		} catch (Exception e) {
			fail("canBeEmpty() threw Exception: " + e.toString());
		}

	}

	// @Test
	// public void testTransactionCommit()
	// {
	// Graph g = getGraphProducer().newGraph();
	// if (g.getTransactionHandler().transactionsSupported())
	// {
	// Graph initial = graphWithTxn( "initial hasValue 42; also hasURI hello" );
	// Graph extra = graphWithTxn( "extra hasValue 17; also hasURI world" );
	// //File foo = FileUtils.tempFileName( "fileGraph", ".nt" );
	//
	// //Graph g = new FileGraph( foo, true, true );
	//
	// GraphUtil.addInto( g, initial );
	// g.getTransactionHandler().begin();
	// GraphUtil.addInto( g, extra );
	// g.getTransactionHandler().commit();
	// Graph union = graphWithTxn( "" );
	// GraphUtil.addInto(union, initial );
	// GraphUtil.addInto(union, extra );
	// assertIsomorphic( union, g );
	// //Model inFile = ModelFactory.createDefaultModel();
	// //inFile.read( "file:///" + foo, "N-TRIPLES" );
	// //assertIsomorphic( union, inFile.getGraph() );
	// }
	// }
	//
	// @Test
	// public void testTransactionAbort()
	// {
	// Graph g = getGraphProducer().newGraph();
	// if (g.getTransactionHandler().transactionsSupported())
	// {
	// Graph initial = graphWithTxn( "initial hasValue 42; also hasURI hello" );
	// Graph extra = graphWithTxn( "extra hasValue 17; also hasURI world" );
	// File foo = FileUtils.tempFileName( "fileGraph", ".n3" );
	// //Graph g = new FileGraph( foo, true, true );
	// GraphUtil.addInto( g, initial );
	// g.getTransactionHandler().begin();
	// GraphUtil.addInto( g, extra );
	// g.getTransactionHandler().abort();
	// assertIsomorphic( initial, g );
	// }
	// }
	//
	// @Test
	// public void testTransactionCommitThenAbort()
	// {
	// Graph g = getGraphProducer().newGraph();
	// if (g.getTransactionHandler().transactionsSupported())
	// {
	// Graph initial = graphWithTxn( "A pings B; B pings C" );
	// Graph extra = graphWithTxn( "C pingedBy B; fileGraph rdf:type Graph" );
	// //Graph g = getGraphProducer().newGraph();
	// //File foo = FileUtils.tempFileName( "fileGraph", ".nt" );
	// //Graph g = new FileGraph( foo, true, true );
	// g.getTransactionHandler().begin();
	// GraphUtil.addInto( g, initial );
	// g.getTransactionHandler().commit();
	// g.getTransactionHandler().begin();
	// GraphUtil.addInto( g, extra );
	// g.getTransactionHandler().abort();
	// assertIsomorphic( initial, g );
	// //Model inFile = ModelFactory.createDefaultModel();
	// // inFile.read( "file:///" + foo, "N-TRIPLES" );
	// //assertIsomorphic( initial, inFile.getGraph() );
	// }
	// }
	@Test
	public void testSizeAfterRemove() {
		Graph g = graphWithTxn("x p y");
		if (g.getCapabilities().iteratorRemoveAllowed()) {
			ExtendedIterator<Triple> it = g.find(triple("x ?? ??"));
			it.removeNext();
			assertEquals(0, g.size());
		}
	}

	@Test
	public void testSingletonStatisticsWithSingleTriple() {

		Graph g = graphWithTxn("a P b");
		GraphStatisticsHandler h = g.getStatisticsHandler();
		if (h != null) {
			assertEquals(1L, h.getStatistic(node("a"), Node.ANY, Node.ANY));
			assertEquals(0L, h.getStatistic(node("x"), Node.ANY, Node.ANY));
			//
			assertEquals(1L, h.getStatistic(Node.ANY, node("P"), Node.ANY));
			assertEquals(0L, h.getStatistic(Node.ANY, node("Q"), Node.ANY));
			//
			assertEquals(1L, h.getStatistic(Node.ANY, Node.ANY, node("b")));
			assertEquals(0L, h.getStatistic(Node.ANY, Node.ANY, node("y")));
		}
	}

	@Test
	public void testSingletonStatisticsWithSeveralTriples() {

		Graph g = graphWithTxn("a P b; a P c; a Q b; x S y");
		GraphStatisticsHandler h = g.getStatisticsHandler();
		if (h != null) {
			assertEquals(3L, h.getStatistic(node("a"), Node.ANY, Node.ANY));
			assertEquals(1L, h.getStatistic(node("x"), Node.ANY, Node.ANY));
			assertEquals(0L, h.getStatistic(node("y"), Node.ANY, Node.ANY));
			//
			assertEquals(2L, h.getStatistic(Node.ANY, node("P"), Node.ANY));
			assertEquals(1L, h.getStatistic(Node.ANY, node("Q"), Node.ANY));
			assertEquals(0L, h.getStatistic(Node.ANY, node("R"), Node.ANY));
			//
			assertEquals(2L, h.getStatistic(Node.ANY, Node.ANY, node("b")));
			assertEquals(1L, h.getStatistic(Node.ANY, Node.ANY, node("c")));
			assertEquals(0L, h.getStatistic(Node.ANY, Node.ANY, node("d")));
		}
	}

	@Test
	public void testDoubletonStatisticsWithTriples() {

		Graph g = graphWithTxn("a P b; a P c; a Q b; x S y");
		GraphStatisticsHandler h = g.getStatisticsHandler();
		if (h != null) {
			assertEquals(-1L, h.getStatistic(node("a"), node("P"), Node.ANY));
			assertEquals(-1L, h.getStatistic(Node.ANY, node("P"), node("b")));
			assertEquals(-1L, h.getStatistic(node("a"), Node.ANY, node("b")));
			//
			assertEquals(0L, h.getStatistic(node("no"), node("P"), Node.ANY));
		}
	}

	@Test
	public void testStatisticsWithOnlyVariables() {
		testStatsWithAllVariables("");
		testStatsWithAllVariables("a P b");
		testStatsWithAllVariables("a P b; a P c");
		testStatsWithAllVariables("a P b; a P c; a Q b; x S y");
	}

	private void testStatsWithAllVariables(String triples) {
		Graph g = graphWithTxn(triples);
		GraphStatisticsHandler h = g.getStatisticsHandler();
		if (h != null) {
			assertEquals(g.size(), h.getStatistic(Node.ANY, Node.ANY, Node.ANY));
		}
	}

	@Test
	public void testStatsWithConcreteTriple() {
		testStatsWithConcreteTriple(0, "x P y", "");
	}

	private void testStatsWithConcreteTriple(int expect, String triple,
			String graph) {
		Graph g = graphWithTxn(graph);
		GraphStatisticsHandler h = g.getStatisticsHandler();
		if (h != null) {
			Triple t = triple(triple);
			assertEquals(
					expect,
					h.getStatistic(t.getSubject(), t.getPredicate(),
							t.getObject()));
		}
	}

	@Test
	public void testBrokenIndexes() {
		Graph g = graphWithTxn("x R y; x S z");
		if (g.getCapabilities().iteratorRemoveAllowed()) {
			ExtendedIterator<Triple> it = g.find(Node.ANY, Node.ANY, Node.ANY);
			it.removeNext();
			it.removeNext();
			assertFalse(g.find(node("x"), Node.ANY, Node.ANY).hasNext());
			assertFalse(g.find(Node.ANY, node("R"), Node.ANY).hasNext());
			assertFalse(g.find(Node.ANY, Node.ANY, node("y")).hasNext());
		}
	}

	@Test
	public void testBrokenSubject() {
		Graph g = graphWithTxn("x brokenSubject y");
		if (g.getCapabilities().iteratorRemoveAllowed()) {
			ExtendedIterator<Triple> it = g.find(node("x"), Node.ANY, Node.ANY);
			it.removeNext();
			assertFalse(g.find(Node.ANY, Node.ANY, Node.ANY).hasNext());
		}
	}

	@Test
	public void testBrokenPredicate() {
		Graph g = graphWithTxn("x brokenPredicate y");
		if (g.getCapabilities().iteratorRemoveAllowed()) {
			ExtendedIterator<Triple> it = g.find(Node.ANY,
					node("brokenPredicate"), Node.ANY);
			it.removeNext();
			assertFalse(g.find(Node.ANY, Node.ANY, Node.ANY).hasNext());
		}
	}

	@Test
	public void testBrokenObject() {
		Graph g = graphWithTxn("x brokenObject y");
		if (g.getCapabilities().iteratorRemoveAllowed()) {
			ExtendedIterator<Triple> it = g.find(Node.ANY, Node.ANY, node("y"));
			it.removeNext();
			assertFalse(g.find(Node.ANY, Node.ANY, Node.ANY).hasNext());
		}
	}

}
